// HTML Minifier vendored browser build (CDN download) with fallback
import minifierSource from "./vendor/htmlminifier.min.js?raw";
let minifyFn = null;

function parseCdnPackageInfo() {
  const src = typeof minifierSource === "string" ? minifierSource : "";
  const name = "html-minifier";
  let version = null;
  // Try common patterns in the vendored CDN header
  const m1 = src.match(/html-minifier\s*v(\d+\.\d+\.\d+)/i);
  const m2 = src.match(/@version\s*([0-9]+\.[0-9]+\.[0-9]+)/i);
  version = (m1 && m1[1]) || (m2 && m2[1]) || null;
  const npmUrl = version
    ? `https://www.npmjs.com/package/${name}/v/${version}`
    : `https://www.npmjs.com/package/${name}`;
  return { name, version, npmUrl };
}

async function ensureMinifierLoaded() {
  if (minifyFn) return true;
  try {
    if (minifierSource && typeof minifierSource === "string" && minifierSource.length > 0) {
      const factory = new Function(
        minifierSource +
          "\nreturn (typeof require===\"function\" ? require(\"html-minifier\") : (self.minify || (self.htmlMinifier && self.htmlMinifier.minify) || null));"
      );
      const mod = factory();
      const candidate = (mod && mod.minify) || mod;
      if (typeof candidate === "function") {
        minifyFn = candidate;
        return true;
      }
    }
  } catch (e) {
    // swallow and fallback
  }
  return false;
}

// Fallback single-line minifier that preserves script/style/pre/textarea blocks
const TOKEN_PREFIX = "__HTML_MIN_BLOCK_";
function extractPreservedBlocks(html) {
  const blocks = [];
  const patterns = [
    { type: "script", re: /<script\b[^>]*>[\s\S]*?<\/script>/gi },
    { type: "style", re: /<style\b[^>]*>[\s\S]*?<\/style>/gi },
    { type: "pre", re: /<pre\b[^>]*>[\s\S]*?<\/pre>/gi },
    { type: "textarea", re: /<textarea\b[^>]*>[\s\S]*?<\/textarea>/gi },
  ];
  let processed = html;
  for (const p of patterns) {
    processed = processed.replace(p.re, (m) => {
      const id = blocks.push({ type: p.type, content: m }) - 1;
      return `${TOKEN_PREFIX}${id}__`;
    });
  }
  return { processed, blocks };
}
function restorePreservedBlocks(html, blocks) {
  return html.replace(new RegExp(`${TOKEN_PREFIX}(\\d+)__`, "g"), (_, idx) => {
    const b = blocks[Number(idx)];
    return b ? b.content : "";
  });
}
function fallbackMinify(html) {
  const { processed, blocks } = extractPreservedBlocks(html || "");
  let s = processed;
  s = s.replace(/<!--(?!\[if)[\s\S]*?-->/g, "");
  s = s.replace(/>\s+</g, "><");
  s = s.replace(/[\r\n\t]+/g, "");
  s = s.replace(/\s{2,}/g, " ").trim();
  s = restorePreservedBlocks(s, blocks);
  return s.replace(/\r?\n+/g, "");
}

// Options matching your desired configuration
const OPTIONS = {
  caseSensitive: false,
  collapseBooleanAttributes: false,
  collapseInlineTagWhitespace: true,
  collapseWhitespace: true,
  conservativeCollapse: false,
  decodeEntities: false,
  html5: true,
  includeAutoGeneratedTags: false,
  keepClosingSlash: false,
  minifyCSS: true,
  minifyJS: true,
  preserveLineBreaks: false,
  preventAttributesEscaping: false,
  processConditionalComments: true,
  processScripts: ["text/html"],
  removeAttributeQuotes: false,
  removeComments: true,
  removeEmptyAttributes: false,
  removeEmptyElements: false,
  removeOptionalTags: false,
  removeRedundantAttributes: false,
  removeScriptTypeAttributes: false,
  removeStyleLinkTypeAttributes: false,
  removeTagWhitespace: false,
  sortAttributes: false,
  sortClassName: false,
  trimCustomFragments: false,
  useShortDoctype: false,
};

self.onmessage = async (e) => {
  const type = e?.data?.type || "minify";
  const html = e?.data?.html ?? "";
  try {
    if (type === "probe") {
      const loaded = await ensureMinifierLoaded();
      const engine = loaded ? "cdn" : "fallback";
      const details = loaded ? parseCdnPackageInfo() : null;
      self.postMessage({
        success: true,
        engine,
        enginePackageName: details?.name || null,
        enginePackageVersion: details?.version || null,
        enginePackageUrl: details?.npmUrl || null,
      });
      return;
    }
    let result;
    const loaded = await ensureMinifierLoaded();
    const engine = loaded ? "cdn" : "fallback";
    const details = loaded ? parseCdnPackageInfo() : null;
    if (loaded) {
      result = minifyFn(html, OPTIONS);
      result = typeof result === "string" ? result.replace(/\r?\n+/g, "") : "";
    } else {
      result = fallbackMinify(html);
    }
    self.postMessage({
      success: true,
      result,
      engine,
      enginePackageName: details?.name || null,
      enginePackageVersion: details?.version || null,
      enginePackageUrl: details?.npmUrl || null,
    });
  } catch (err) {
    self.postMessage({ success: false, error: err?.message || String(err) });
  }
};
